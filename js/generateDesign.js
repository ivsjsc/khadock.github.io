// js/generateDesign.js

document.addEventListener('DOMContentLoaded', () => {
    // Main AI Design Elements
    const generateBtn = document.getElementById('ai-generate-btn');
    const clearInputBtn = document.getElementById('ai-clear-input-btn');
    const inputText = document.getElementById('ai-design-input');
    const loadingDiv = document.getElementById('ai-loading');
    const loadingTextElement = document.getElementById('ai-loading-text');
    const errorDiv = document.getElementById('ai-error');
    const outputContainer = document.getElementById('ai-output-container');
    const mainOutputDiv = document.getElementById('ai-output');

    // Elements for Additional Gemini Features
    const extraFeaturesContainer = document.getElementById('gemini-extra-features');
    const maintenanceBtn = document.getElementById('ai-maintenance-btn');
    const accessoriesBtn = document.getElementById('ai-accessories-btn');
    const maintenanceLoadingDiv = document.getElementById('ai-maintenance-loading');
    const accessoriesLoadingDiv = document.getElementById('ai-accessories-loading');
    const maintenanceOutputDiv = document.getElementById('ai-maintenance-output');
    const accessoriesOutputDiv = document.getElementById('ai-accessories-output');

    let currentDesignConceptEN = ""; // Store the generated design concept in English

    // IMPORTANT: API Key is NO LONGER stored in client-side JavaScript.
    // It must be securely stored and used by your backend server.

    function setLoadingState(isLoading, type = 'main') {
        let loader, textEl, buttonEl;
        let loadingMessage = "Loading..."; // Default loading message

        if (type === 'main') {
            loader = loadingDiv;
            textEl = loadingTextElement;
            buttonEl = generateBtn;
            loadingMessage = "Generating your idea..."; // Specific message
        } else if (type === 'maintenance') {
            loader = maintenanceLoadingDiv;
            buttonEl = maintenanceBtn;
            loadingMessage = "Loading maintenance tips..."; // Specific message
        } else if (type === 'accessories') {
            loader = accessoriesLoadingDiv;
            buttonEl = accessoriesBtn;
            loadingMessage = "Loading accessory suggestions..."; // Specific message
        }

        if (loader) loader.classList.toggle('hidden', !isLoading);
        if (textEl && isLoading) textEl.textContent = loadingMessage; // Set the specific loading message
        if (buttonEl) {
            buttonEl.disabled = isLoading;
            buttonEl.classList.toggle('opacity-75', isLoading);
            buttonEl.classList.toggle('cursor-not-allowed', isLoading);
        }

        if (isLoading) {
            if(errorDiv) errorDiv.classList.add('hidden');
            if (type === 'main' && outputContainer) outputContainer.classList.add('hidden');
            if (type === 'maintenance' && maintenanceOutputDiv) maintenanceOutputDiv.classList.add('hidden');
            if (type === 'accessories' && accessoriesOutputDiv) accessoriesOutputDiv.classList.add('hidden');
        }
    }

    function displayError(message) {
        if (!errorDiv) return;
        errorDiv.textContent = message;
        errorDiv.classList.remove('hidden');
        if (outputContainer) outputContainer.classList.add('hidden');
    }

    function displayResult(htmlContent, targetDiv, title = "KhaDock AI Design Concept:") {
        if (!targetDiv) return;
        // The title is now part of the htmlContent generated by formatGeminiTextToEnglish
        // or should be prepended before calling displayResult if not.
        targetDiv.innerHTML = htmlContent;

        targetDiv.classList.remove('hidden');
        if (targetDiv.closest('#ai-output-container')) {
             if(outputContainer) outputContainer.classList.remove('hidden');
        }
        if(errorDiv) errorDiv.classList.add('hidden');
    }

    function formatGeminiTextToEnglish(text, title) { // Added title parameter
        if (!text) return `<h3 class="text-xl font-semibold text-sky-800 mb-3">${title}</h3><p>No content to display.</p>`;
        
        let html = `<h3 class="text-xl font-semibold text-sky-800 mb-3">${title}</h3>`; // Prepend title
        
        // Process the rest of the text
        let contentHtml = text;
        contentHtml = contentHtml.replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="bg-slate-200 p-2 rounded overflow-x-auto text-sm"><code>${p1.trim()}</code></pre>`);
        contentHtml = contentHtml.replace(/\*\*(.*?):\*\*/g, (match, p1) => `<h4 class="text-lg font-semibold text-sky-700 mt-3 mb-1">${p1.trim()}:</h4>`);
        contentHtml = contentHtml.replace(/(\d+\.\s*\*\*(.*?):\*\*)/g, (match, p1, p2) => `<h4 class="text-lg font-semibold text-sky-700 mt-3 mb-1">${p2.trim()}:</h4>`);
        contentHtml = contentHtml.replace(/(?<!\d\.\s*)\*\*(.*?)\*\*/g, '<strong>$1</strong>');

        const lines = contentHtml.split('\n');
        let inList = false;
        contentHtml = lines.map(line => {
            line = line.trim();
            if (line.match(/^[\*\-]\s+/)) {
                let listItem = line.replace(/^[\*\-]\s+/, '').trim();
                listItem = listItem.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                if (!inList) {
                    inList = true;
                    return `<ul><li>${listItem}</li>`;
                }
                return `<li>${listItem}</li>`;
            } else {
                if (inList) {
                    inList = false;
                    // Check if the line is empty or already a block element before wrapping in <p>
                    if (line.match(/^<h[1-6]>/) || line.match(/^<ul>/) || line.match(/^<pre>/) || line.trim() === '') {
                         return `</ul>${line}`;
                    }
                    return `</ul>${line ? `<p>${line}</p>` : ''}`;
                }
                if (line.match(/^<h[1-6]>/) || line.match(/^<ul>/) || line.match(/^<pre>/) || line.trim() === '') {
                    return line;
                }
                return line ? `<p>${line}</p>` : '';
            }
        }).join('');
        if (inList) contentHtml += '</ul>';
        contentHtml = contentHtml.replace(/<p>\s*<\/p>/g, '');
        contentHtml = contentHtml.replace(/<\/ul>\s*<ul>/g, '');
        
        return html + contentHtml; // Combine title and formatted content
    }

    // Updated function to call your backend proxy
    async function callBackendAPI(promptText, targetLanguage = "English", type = "design") {
        // Endpoint for your backend proxy. Adjust if necessary.
        const backendApiUrl = "http://localhost:3001/api/khadock-gemini-proxy";

        // The payload to send to your backend.
        // Your backend will then use this to construct the full request to Gemini.
        const payloadToBackend = {
            prompt: promptText,
            targetLanguage: targetLanguage,
            requestType: type // To help backend differentiate requests if needed
        };

        try {
            const response = await fetch(backendApiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payloadToBackend)
            });

            if (!response.ok) {
                let errorData;
                try {
                    errorData = await response.json();
                } catch (e) {
                    // If response is not JSON, use status text or a generic message
                    errorData = { message: response.statusText || `Backend request failed with status: ${response.status}` };
                }
                const errorMessage = errorData?.error?.message || errorData.message || `Backend request failed.`;
                console.error("Backend Error Data:", errorData);
                throw new Error(errorMessage);
            }

            const result = await response.json();

            // Assuming your backend forwards the 'text' part of the Gemini response
            if (result && result.text) {
                return result.text;
            } else if (result && result.error) { // Handle errors forwarded by backend
                throw new Error(result.error.message || "An error occurred at the backend.");
            }
            else {
                console.error("Invalid response structure from backend:", result);
                throw new Error('Received an unexpected response structure from the backend. Please try again.');
            }
        } catch (error) {
            console.error("Error calling backend API:", error);
            // Re-throw the error so it can be caught by the calling function
            throw error;
        }
    }


    async function generateInitialDesign() {
        if (!inputText || !mainOutputDiv) {
            console.error("Required DOM elements for main design generation are missing.");
            return;
        }
        const userInput = inputText.value.trim();
        if (!userInput) {
            displayError('Please describe your dock idea.');
            inputText.focus();
            return;
        }

        setLoadingState(true, 'main');
        currentDesignConceptEN = "";
        if(extraFeaturesContainer) extraFeaturesContainer.classList.add('hidden');
        if(maintenanceOutputDiv) maintenanceOutputDiv.classList.add('hidden');
        if(accessoriesOutputDiv) accessoriesOutputDiv.classList.add('hidden');

        const promptForDesignEN = `As a creative dock design expert for KhaDock.com in Florida, generate a detailed and inspiring boat dock concept based on the following user input: "${userInput}".
Provide the response in English, well-structured with Markdown for bold titles (e.g., **Concept Name:**), including:
1.  **Concept Name:** (A catchy, descriptive name)
2.  **Overall Vision:** (1-2 sentences describing the main idea and feel)
3.  **Key Features & Functionality:** (List 3-5 distinct features with brief descriptions, using bullet points)
4.  **Suggested Materials:** (List 2-3 primary materials suitable for Florida, using bullet points)
5.  **Aesthetic Style:** (1-2 sentences describing the look and feel)
6.  **Best Suited For:** (1 sentence about ideal users or property type)
Ensure the concept is practical for Florida's coastal environment (sun, saltwater, storms). Total length around 150-250 words.`;

        try {
            const designText = await callBackendAPI(promptForDesignEN, "English", "initialDesign");
            currentDesignConceptEN = designText; // Store the raw English text from AI
            const formattedHtml = formatGeminiTextToEnglish(designText, "KhaDock AI Design Concept:");
            displayResult(formattedHtml, mainOutputDiv); // Title is now part of formattedHtml
            if (outputContainer) outputContainer.classList.remove('hidden');
            if (extraFeaturesContainer) extraFeaturesContainer.classList.remove('hidden');
        } catch (error) {
            displayError(`Error: ${error.message}`);
            console.error('Error generating initial design:', error);
        } finally {
            setLoadingState(false, 'main');
        }
    }

    async function getMaintenanceTips() {
        if (!currentDesignConceptEN) {
            displayError("Please generate a design concept first before requesting maintenance tips.");
            return;
        }
        if (!maintenanceOutputDiv) return;

        setLoadingState(true, 'maintenance');
        const promptForMaintenanceEN = `Based on the following Florida dock design concept: "${currentDesignConceptEN}", provide 3-5 important and specific maintenance tips in English. Focus on materials mentioned, the Florida climate, and common issues. Present as a bulleted list.`;

        try {
            const tipsText = await callBackendAPI(promptForMaintenanceEN, "English", "maintenanceTips");
            const formattedHtml = formatGeminiTextToEnglish(tipsText, "✨ Maintenance Tips for This Design:");
            displayResult(formattedHtml, maintenanceOutputDiv);
        } catch (error) {
            const errorHtml = formatGeminiTextToEnglish(`Error fetching maintenance tips: ${error.message}`, "Maintenance Tips Error");
            displayResult(errorHtml, maintenanceOutputDiv);
            console.error('Error fetching maintenance tips:', error);
        } finally {
            setLoadingState(false, 'maintenance');
        }
    }

    async function getAccessorySuggestions() {
        if (!currentDesignConceptEN) {
            displayError("Please generate a design concept first before requesting accessory suggestions.");
            return;
        }
        if (!accessoriesOutputDiv) return;

        setLoadingState(true, 'accessories');
        const promptForAccessoriesEN = `For the following Florida dock design: "${currentDesignConceptEN}", suggest 3-5 suitable and useful accessories in English. Briefly explain why each accessory is a good fit. Present as a bulleted list.`;

        try {
            const accessoriesText = await callBackendAPI(promptForAccessoriesEN, "English", "accessorySuggestions");
            const formattedHtml = formatGeminiTextToEnglish(accessoriesText, "✨ Suggested Accessories for This Design:");
            displayResult(formattedHtml, accessoriesOutputDiv);
        } catch (error) {
            const errorHtml = formatGeminiTextToEnglish(`Error fetching accessory suggestions: ${error.message}`, "Accessory Suggestions Error");
            displayResult(errorHtml, accessoriesOutputDiv);
            console.error('Error fetching accessory suggestions:', error);
        } finally {
            setLoadingState(false, 'accessories');
        }
    }

    // Event Listeners
    if (generateBtn) generateBtn.addEventListener('click', generateInitialDesign);
    if (clearInputBtn && inputText) {
        clearInputBtn.addEventListener('click', () => {
            inputText.value = '';
            if(errorDiv) errorDiv.classList.add('hidden');
            if(outputContainer) outputContainer.classList.add('hidden');
            currentDesignConceptEN = "";
            if(extraFeaturesContainer) extraFeaturesContainer.classList.add('hidden');
            if(maintenanceOutputDiv) maintenanceOutputDiv.classList.add('hidden');
            if(accessoriesOutputDiv) accessoriesOutputDiv.classList.add('hidden');
            inputText.focus();
        });
    }
    if (maintenanceBtn) maintenanceBtn.addEventListener('click', getMaintenanceTips);
    if (accessoriesBtn) accessoriesBtn.addEventListener('click', getAccessorySuggestions);
    if (inputText) {
        inputText.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                generateInitialDesign();
            }
        });
    }
});
